"""
Utility / metadata endpoints.

Serves /meta/cmas and /meta/data-freshness.
"""

from __future__ import annotations

import json
from pathlib import Path

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel

from candata_shared.db import get_supabase_client

router = APIRouter(prefix="/meta", tags=["meta"])

_CACHE = {"Cache-Control": "max-age=3600"}

# Freshness report lives at <repo_root>/monitoring/freshness_report.json.
# Walk up from this file to find the repo root.
_REPO_ROOT = Path(__file__).resolve().parents[5]  # routers -> candata_api -> src -> api -> packages -> root
_FRESHNESS_REPORT = _REPO_ROOT / "monitoring" / "freshness_report.json"


# ---------------------------------------------------------------------------
# Response models
# ---------------------------------------------------------------------------


class CmaListItem(BaseModel):
    cma_name: str
    cma_geoid: str
    latest_date: str
    record_count: int


# ---------------------------------------------------------------------------
# GET /meta/cmas
# ---------------------------------------------------------------------------


@router.get(
    "/cmas",
    response_model=list[CmaListItem],
    summary="List all CMAs with metadata",
)
async def list_cmas() -> JSONResponse:
    """
    Full list of CMAs found in `cmhc_housing`, with their geoUIDs, latest
    available data month, and total row count.

    Useful for populating CMA selector dropdowns in front-end applications
    and for validating geoUID values before calling other housing endpoints.
    """
    supabase = get_supabase_client()

    rows = (
        supabase.table("cmhc_housing")
        .select("cma_name,cma_geoid,year,month")
        .order("cma_name")
        .limit(200_000)
        .execute()
    ).data

    stats: dict[str, dict] = {}
    for row in rows:
        key = row["cma_geoid"]
        if key not in stats:
            stats[key] = {
                "cma_name": row["cma_name"],
                "cma_geoid": key,
                "latest_year": row["year"],
                "latest_month": row["month"],
                "record_count": 0,
            }
        stats[key]["record_count"] += 1
        if (row["year"], row["month"]) > (
            stats[key]["latest_year"],
            stats[key]["latest_month"],
        ):
            stats[key]["latest_year"] = row["year"]
            stats[key]["latest_month"] = row["month"]

    output = [
        {
            "cma_name": info["cma_name"],
            "cma_geoid": info["cma_geoid"],
            "latest_date": f"{info['latest_year']}-{info['latest_month']:02d}",
            "record_count": info["record_count"],
        }
        for info in sorted(stats.values(), key=lambda x: x["cma_name"])
    ]
    return JSONResponse(content=output, headers=_CACHE)


# ---------------------------------------------------------------------------
# GET /meta/data-freshness
# ---------------------------------------------------------------------------


@router.get(
    "/data-freshness",
    summary="Latest freshness report for all pipeline tables",
)
async def data_freshness() -> JSONResponse:
    """
    Returns the latest freshness report generated by
    ``monitoring/freshness_check.py``.

    If the report JSON has not been generated yet, returns HTTP 503.
    """
    if not _FRESHNESS_REPORT.exists():
        return JSONResponse(
            status_code=503,
            content={
                "detail": (
                    "Freshness report not yet generated "
                    "â€” run monitoring/freshness_check.py first."
                )
            },
        )

    report = json.loads(_FRESHNESS_REPORT.read_text())
    return JSONResponse(content=report, headers=_CACHE)
